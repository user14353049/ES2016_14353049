#Lab4:死锁（Windows版）

##一、死锁产生的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用 
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 
3.  不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺 
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

##二、死锁停在第几次的截图：

### 按照PPT的要求创建Deadlock.java文件，并运行，然后再创建Deadlock.bat文件，之后运行见下图：

![https://ooo.0o0.ooo/2016/11/12/5826a9c5a3fac.png](https://ooo.0o0.ooo/2016/11/12/5826a9c5a3fac.png)

####第一次停在了6的位置：
![https://ooo.0o0.ooo/2016/11/12/5826a9c5a57ae.png](https://ooo.0o0.ooo/2016/11/12/5826a9c5a57ae.png)
####第二次停在了216的位置：
![https://ooo.0o0.ooo/2016/11/12/5826a9c5a5f59.png](https://ooo.0o0.ooo/2016/11/12/5826a9c5a5f59.png)
####第三次停在了58的位置：
![https://ooo.0o0.ooo/2016/11/12/5826a9c5c2760.png](https://ooo.0o0.ooo/2016/11/12/5826a9c5c2760.png)

##三、产生死锁的解释：
Deadlock.java代码中我们定义类A、B的方法为synchronized的类型，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，然后在主函数中这里的做法是用类A调用类B的资源，再从类B调用类A的资源，反复执行，直到出现，当类A准备调用类B时类类B还没释放资源，刚好此时类B遭到阻塞未能释放资源，然后出现了死锁，同理类B调用类A时也会有这种情况。出现阻塞的情况是若干进程之间形成一种头尾相接的循环等待资源关系。